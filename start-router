#!/bin/bash

#
# Required debian packages
#
# wide-dhcpv6-client (dhcp6c)
# radvd
# iptables
# udhcpd
# iproute (ip)
# net-tools (route)
# ndisc6 (rdisc6)
# hostapd
# bridge-utils

set -e
set -x

export PATH=$PATH:/sbin

SCRIPTDIR=$(dirname $0)

function ok_fail ()
{
	if ! $@; then
		true; # nothing really
	fi
}

function reset_networking ()
{
	dhclient -x
	# TODO maybe release lease

	if ! killall dhcpd; then
		true; # nothing
	fi

	if ! killall wpa_supplicant; then
		true; # nothing
	fi

	if ! killall dhclient; then
		true; # nothing
	fi

	if ! killall -9 dhcp6c; then
		true; # nothing
	fi

	while pgrep dhcp6c; do
		echo "Waiting for dhcp6c to die..."
		sleep 1
	done

	if ! killall radvd; then
		true; # nothing
	fi

	if ! killall rdiscd; then
		true; # nothing
	fi

	ifconfig $wan_if down
	ip addr flush dev $wan_if

	ok_fail ifconfig $lan_if down
	ok_fail ip addr flush dev $lan_if

	ifconfig $wired_lan_if down
	ip addr flush dev $wired_lan_if

	ifconfig $wifi_ap_if down
	ip addr flush dev $wifi_ap_if

	ifconfig $wlan_if down
	ip addr flush dev $wlan_if

	both_iptables -F INPUT
	both_iptables -F FORWARD
	both_iptables -F OUTPUT
	iptables -t nat -F POSTROUTING

	# Disable ipv4 forwarding
	echo 0 >/proc/sys/net/ipv4/ip_forward

	# Disable ipv6 forwarding
	echo 0 >/proc/sys/net/ipv6/conf/all/forwarding

	# Restore ipv6 default ra accept behavior
	echo 1 >/proc/sys/net/ipv6/conf/$wan_if/accept_ra

	ok_fail killall hostapd

	ok_fail brctl delbr $lan_if
}

function both_iptables ()
{
	iptables $@
	ip6tables $@
}

function wait_for_ip6_addr ()
{
	if=$1

	seconds=0
	while [ "$(ip -6 addr show dev $if scope global | wc -l)" = "0" ]; do
		if [ "$seconds" -gt 10 ]; then
			# timed out
			return 1
		fi
		echo "Waiting for ip6 address on $if..."
		sleep 1
		seconds=$(($seconds+1))

	done

	return 0
}

function start_wifi_ap ()
{
	echo "
interface=${wifi_ap_interface}
logger_syslog=-1
logger_syslog_level=2
logger_stdout=-1
logger_stdout_level=2
ctrl_interface=/var/run/hostapd
ctrl_interface_group=0
ssid=${wifi_ap_ssid}
hw_mode=g
channel=11
beacon_int=100
dtim_period=2
max_num_sta=255
rts_threshold=2347
fragm_threshold=2346
supported_rates=10 20 55 110 60 90 120 180 240 360 480 540
macaddr_acl=0
ignore_broadcast_ssid=0
wmm_enabled=1
wmm_ac_bk_cwmin=4
wmm_ac_bk_cwmax=10
wmm_ac_bk_aifs=7
wmm_ac_bk_txop_limit=0
wmm_ac_bk_acm=0
wmm_ac_be_aifs=3
wmm_ac_be_cwmin=4
wmm_ac_be_cwmax=10
wmm_ac_be_txop_limit=0
wmm_ac_be_acm=0
wmm_ac_vi_aifs=2
wmm_ac_vi_cwmin=3
wmm_ac_vi_cwmax=4
wmm_ac_vi_txop_limit=94
wmm_ac_vi_acm=0
wmm_ac_vo_aifs=2
wmm_ac_vo_cwmin=2
wmm_ac_vo_cwmax=3
wmm_ac_vo_txop_limit=47
wmm_ac_vo_acm=0
eapol_key_index_workaround=0
eap_server=0
own_ip_addr=127.0.0.1
wpa=2
wpa_passphrase=${wifi_ap_passphrase}
wpa_key_mgmt=WPA-PSK
wpa_pairwise=TKIP
rsn_pairwise=CCMP
" >/tmp/hostapd.conf

	hostapd -B /tmp/hostapd.conf
}

function start_dhcp_server () {
	echo "
subnet 192.168.1.0 netmask 255.255.255.0 {
	option routers                  192.168.1.1;
	option subnet-mask              255.255.255.0;

#	option domain-name              "example.com";
	option domain-name-servers       8.8.8.8, 8.8.4.4;

#	option time-offset              -18000;     # Eastern Standard Time

	range 192.168.1.100 192.168.1.200;

" >/tmp/dhcpd.conf

	grep -v '^#' $SCRIPTDIR/static_dhcp.conf | while read line; do

		IFS=',' read -ra FIELDS <<< "$line"
		host=${FIELDS[0]}
		eth=${FIELDS[1]}
		ip=${FIELDS[2]}
		echo -e "\thost $host {
		hardware ethernet $eth;
		fixed-address $ip;
	}" >>/tmp/dhcpd.conf
	done

	echo "}" >>/tmp/dhcpd.conf

	dhcpd -cf /tmp/dhcpd.conf $an_if
}


source $SCRIPTDIR/router.conf

reset_networking


# FIREWALL
### Setup the firewall before we bring up anything

# Allow local traffic
both_iptables -A INPUT -i lo -j ACCEPT

# Accept all related traffic
both_iptables -A INPUT -m conntrack --ctstate ESTABLISHED,RELATED -j ACCEPT

# LAN services
both_iptables -A INPUT -p tcp -i $lan_if --dport ssh -j ACCEPT
both_iptables -A INPUT -p tcp -i $lan_if --dport 8000 -j ACCEPT #routerpy
iptables -A INPUT -p udp -i $lan_if --dport bootps -j ACCEPT
iptables -A INPUT -p udp --dport 53 -j ACCEPT
ip6tables -A INPUT -p udp -i $lan_if --dport dhcpv6-client -j ACCEPT
ip6tables -A INPUT -p udp -i $lan_if --dport 5353 -j ACCEPT

# Somehow the conntrack won't recognize inbound dhcpv6 replies as related to
# the request. May have something to do with requests being sent to multicast
# address, but replies being received from unicast
ip6tables -A INPUT -p udp --dport dhcpv6-client -j ACCEPT
ip6tables -A INPUT -p icmpv6 -j ACCEPT

# Drop everything else
both_iptables -A INPUT -j DROP


# ROUTING

# IPv6: Accept only established forwarding from wan
ip6tables -A FORWARD -m conntrack -i $wan_if --ctstate ESTABLISHED,RELATED -j ACCEPT

# Forward traffic that 
ip6tables -A FORWARD -i $wlan_if -j ACCEPT
ip6tables -A FORWARD -i $lan_if -j ACCEPT

# Drop everything else
ip6tables -A FORWARD -j DROP


# BRING UP INTERFACES

# Bring up wifi access point
start_wifi_ap

# Start lan bridge
brctl addbr br0
brctl addif br0 $wifi_ap_if
brctl addif br0 $wired_lan_if

# Bring up wan/ipv4 - use dhcp
# We don't want too much stuff here. We skip DNS as we won't use the isp's DNS.
echo "request routers, subnet-mask, broadcast-address, time-offset,
	interface-mtu, ntp-servers;" >/tmp/dhclient-${wan_if}.conf
dhclient -cf /tmp/dhclient-${wan_if}.conf $wan_if

# Bring up lan
ifconfig $wifi_ap_if up
ifconfig $wired_lan_if up
ifconfig $lan_if up $lan_ip netmask $lan_netmask

# Bring up wan/ipv6 - use dhcp

# Before doing anything else, setup the wan interface to accept RA's even
# though it will be in router mode. This has to be done before the interface
# comes up, otherwise a manual router discovery packet would have to be sent to
# force the kernel to refresh the routers.
echo 2 >/proc/sys/net/ipv6/conf/$wan_if/accept_ra

# We ask both for a prefix delegation (ia-pd) which we'll use for the lan and
# an address for the wan (ia-na). I haven't found a way of obtaining a router
# from dhcpv6, so the default router is set later. Also, my isp doesn't seem to
# provide a DNS server over dhcpv6. But we want to use the google dns server
# anyway.
echo "interface $wan_if {
     send ia-pd 0;
     send ia-na 0;
};

id-assoc na 0 {};

id-assoc pd {
     prefix-interface $lan_if {
	     sla-id 1;
             sla-len 0;
     };
};" >/tmp/dhcp6c.conf
dhcp6c -c /tmp/dhcp6c.conf $wan_if

# Setup static nameservers - Google public DNS
echo "nameserver 8.8.8.8
nameserver 8.8.4.4
nameserver 2001:4860:4860::8888
nameserver 2001:4860:4860::8844" >/etc/resolv.conf

# Setup IPv4 routing
iptables -A POSTROUTING -t nat -o $wan_if -j MASQUERADE
echo 1 >/proc/sys/net/ipv4/ip_forward

# Setup IPv6 routing
echo 1 >/proc/sys/net/ipv6/conf/all/forwarding


# START SERVICES

start_dhcp_server

# Router advertizement
# This lets other computers on the lan know about the prefix we've been
# delegated so that they can statically autoconfigure their ipv6 interface.
# Typically, they will take two addresses with this prefix. One based on their
# mac address and another determined randomly.
#
# The special prefix ::/64 will automatically pickup the prefixes of the
# configured addresses on that interface.
#
# We need to wait for the wan's dhcpv6 address to be set up, otherwise radvd
# won't advertize.
if wait_for_ip6_addr $wan_if; then
	echo "interface $lan_if {
		AdvSendAdvert on;
		prefix ::/64
		{
			AdvOnLink on;
			AdvAutonomous on;
		};
		RDNSS 2001:4860:4860::8888 2001:4860:4860::8844
		{
		};
	};" >/tmp/radvd.conf
	radvd -C /tmp/radvd.conf
else
	echo "Couldn't get an ipv6 address" >/dev/stderr
fi


# RDISCD
# My cable company (Time Warner cable) does not send unsolicited router
# advertisements.  Therefore, after the initial lifetime of the advertisement
# which is received when the interface comes up, the default route expires and
# ipv6 communications become impossible. Therefore, we start a custom daemon to
# periodically send solicitations.

$SCRIPTDIR/rdiscd $wan_if 60 &
